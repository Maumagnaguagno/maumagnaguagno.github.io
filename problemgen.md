---
title: Problem Generation
description: Generating problems for planning domains
date: 2019-04-19
category: planning
hidden: true
---

# Problem Generation
Differently from domain descriptions where expert knowledge is required to correctly describe domain details, problems can be generated by scripts.
Most scripts are simple and will only generate a single type output, despite many planning description languages being available.
**TODO**

```ruby
require_relative 'HyperTensioN/compilers/PDDL_Compiler.rb'

disks = ARGV.first.to_i

domain_name = 'hanoi'
state = []
goal_pos = []
goal_not = []

pegs = ['peg1', 'peg2', 'peg3']

1.upto(disks) {|n|
  problem_name = "pb#{n}"
  1.upto(n) {|i|
    di = "d#{i}"
    pegs.each {|p| state << ['smaller', di, p]}
    i.upto(n) {|j| state << ['smaller', di, "d#{j}"]}
  }
  state.push(['clear', 'd1'], ['clear', 'peg2'], ['clear', 'peg3'], ['on', "d#{n}", 'peg1'])
  goal_pos << ['on', "d#{n}", 'peg3']
  n.pred.downto(1) {|i|
    state    << ['on', "d#{i}", "d#{i.pred}"]
    goal_pos << ['on', "d#{i}", "d#{i.pred}"]
  }
  pddl = PDDL_Compiler.compile_problem(domain_name, problem_name, nil, nil, nil, state, nil, goal_pos, goal_not, nil)
  IO.write("#{problem_name}.pddl", pddl)
  # TODO only add more elements instead of cleaning all up
  state.clear
  goal_pos.clear
}
```